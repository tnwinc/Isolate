// Generated by CoffeeScript 1.9.2
(function() {
  var hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  (function(root, factory) {
    if (typeof exports === 'object') {
      return module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else {
      return root.Isolate = factory();
    }
  })(this, function() {
    var IsolationContext, IsolationFactory, build_dependencies, getMatcherForPath, getType, passthru;
    getType = function(o) {
      return Object.prototype.toString.call(o);
    };
    passthru = function(actual) {
      return actual;
    };
    getMatcherForPath = function(path, greedy) {
      var path_type, suffix;
      path_type = getType(path);
      if (path_type === '[object RegExp]') {
        return path;
      } else if (path_type === '[object String]') {
        if (path[0] + path.slice(-1) === '//') {
          return new RegExp(path.slice(1, -2));
        } else {
          suffix = greedy ? "[/.].*" : "[.][a-zA-Z]{1,3}";
          return new RegExp("(^|[^a-zA-Z0-9_])" + path + "(" + suffix + ")?$");
        }
      }
      throw Error("Expected either a String or RegExp, but got " + (getType(path)));
    };
    build_dependencies = function(dependencies) {
      dependencies.find = function(val) {
        var matching_dependencies, mod, path, regex;
        regex = getMatcherForPath(val);
        matching_dependencies = [];
        for (path in dependencies) {
          if (!hasProp.call(dependencies, path)) continue;
          mod = dependencies[path];
          if (0 === path.indexOf('isolate!')) {
            continue;
          }
          if (regex.test(path)) {
            matching_dependencies.push(path);
          }
        }
        if (matching_dependencies.length > 1) {
          throw Error("Ambiguous call to find dependency: '" + val + "' matched: [" + matching_dependencies + "]");
        }
        return dependencies[matching_dependencies[0]];
      };
      return dependencies;
    };
    IsolationFactory = (function() {
      function IsolationFactory(factory1) {
        this.factory = factory1;
      }

      return IsolationFactory;

    })();
    IsolationContext = (function() {
      function IsolationContext(name1) {
        var that;
        this.name = name1 != null ? name1 : 'default';
        this.mapAsFactory = bind(this.mapAsFactory, this);
        this.reset = bind(this.reset, this);
        this.willRequire = bind(this.willRequire, this);
        this.mapType = bind(this.mapType, this);
        this.map = bind(this.map, this);
        this.passthru = bind(this.passthru, this);
        this.useRequire = bind(this.useRequire, this);
        this.load = bind(this.load, this);
        this.findMatchingHandler = bind(this.findMatchingHandler, this);
        this.processDependency = bind(this.processDependency, this);
        IsolationContext.contexts[this.name] = this;
        this.rules = [];
        this.typeHandlers = {};
        if (this.env === 'commonjs') {
          that = this;
          Object.getPrototypeOf(module).isolate = function(mod) {
            return that.require(mod, this);
          };
        }
      }

      IsolationContext.prototype.processDependency = function(path, actual, parent_module_path) {
        var handler;
        handler = this.findMatchingHandler(path, actual);
        if (handler == null) {
          throw Error("Failed to generate fake for module [" + path + "] of type [" + (getType(actual)) + "] while isolating module [" + parent_module_path + "]");
        }
        return handler.call(this, actual, path, parent_module_path);
      };

      IsolationContext.prototype.findMatchingHandler = function(path, actual) {
        var fakeModule, fakeModulePath, i, len, ref, rule, typeHandler;
        ref = this.rules;
        for (i = 0, len = ref.length; i < len; i++) {
          rule = ref[i];
          if (rule.matcher.test(path)) {
            return rule.handler;
          }
        }
        typeHandler = this.typeHandlers[getType(actual).toLowerCase()];
        if (typeHandler != null) {
          return typeHandler;
        }
        if (this.env === 'commonjs') {
          fakeModulePath = path.replace('.js', '.isolate-fake.js');
          try {
            fakeModule = require(fakeModulePath);
          } catch (_error) {}
          return fakeModule;
        }
      };

      IsolationContext.prototype.require = function(requested_module, context) {
        var actual, dependencies, err, full_module_path, handler, i, isolatedModule, len, path, ref, ref1, ref2, urlForException;
        context = context || this;
        full_module_path = module.constructor._resolveFilename(requested_module, context);
        module.constructor._cache = {};
        try {
          require(full_module_path);
        } catch (_error) {
          err = _error;
          urlForException = "https://github.com/tnwinc/Isolate/wiki/Error:-An-error-occurred-while-preparing-to-isolate-the-module";
          err.message = "An error occurred while preparing to isolate the module: " + requested_module + "\nFor more information, see " + urlForException + "\nInner Exception:\n" + err.message;
          throw err;
        }
        delete module.constructor._cache[full_module_path];
        dependencies = {};
        ref = module.constructor._cache;
        for (path in ref) {
          if (!hasProp.call(ref, path)) continue;
          actual = ref[path];
          actual.exports = dependencies[path] = this.processDependency(path, actual.exports, full_module_path);
          actual.exports.actual = actual;
        }
        isolatedModule = require(full_module_path);
        isolatedModule.dependencies = build_dependencies(dependencies);
        module.constructor._cache = {};
        if ((ref1 = this.isolateCompleteHandlers) != null ? ref1.length : void 0) {
          ref2 = this.isolateCompleteHandlers;
          for (i = 0, len = ref2.length; i < len; i++) {
            handler = ref2[i];
            handler(isolatedModule);
          }
        }
        return isolatedModule;
      };

      IsolationContext.prototype.load = function(requested_module, req, load, config) {
        var _i, err, isolatedContextName, isolatedRequire, isolatedRequireCtx, isolationContextName, isolationCtx, mainCtx, modulesToLoad, ref, ref1, ref2, ref3, ref4, urlForException;
        IsolationContext._require || (IsolationContext._require = require);
        if ((_i = requested_module.indexOf(':')) > -1) {
          ref = requested_module.split(':'), isolationContextName = ref[0], requested_module = ref[1];
        } else {
          isolationContextName = 'default';
        }
        isolationCtx = IsolationContext.contexts[isolationContextName];
        mainCtx = ((ref1 = IsolationContext._require) != null ? (ref2 = ref1.s) != null ? (ref3 = ref2.contexts) != null ? ref3['_'] : void 0 : void 0 : void 0) || ((ref4 = IsolationContext._require) != null ? ref4.context : void 0);
        isolatedContextName = "isolated_" + (Math.floor(Math.random() * 100000));
        isolationCtx.require = isolatedRequire = IsolationContext._require.config({
          context: isolatedContextName,
          baseUrl: mainCtx.config.baseUrl
        });
        isolatedRequireCtx = IsolationContext._require.s.contexts[isolatedContextName];
        modulesToLoad = [requested_module].concat(isolationCtx.ensuredAsyncModules || []);
        try {
          return req(modulesToLoad, (function(_this) {
            return function(mod) {
              var _module, dependencies, modName, modVal, ref5, ref6, reload, undef;
              undef = isolatedRequireCtx.undef || ((ref5 = isolatedRequireCtx.require) != null ? ref5.undef : void 0);
              for (_module in isolatedRequireCtx.defined) {
                undef(_module);
              }
              ref6 = mainCtx.defined;
              for (modName in ref6) {
                if (!hasProp.call(ref6, modName)) continue;
                modVal = ref6[modName];
                if (modName === requested_module || modName === 'isolate') {
                  continue;
                }
                isolatedRequireCtx.defined[modName] = isolationCtx.processDependency(modName, modVal, requested_module);
              }
              dependencies = build_dependencies(isolatedRequireCtx.defined);
              reload = function(done) {
                undef(requested_module);
                return isolatedRequire([requested_module], (function(_this) {
                  return function(isolatedModule) {
                    var handler, i, j, key, len, len1, ref7, ref8, ref9, reload_method_name;
                    if (isolatedModule == null) {
                      throw Error("The requested module " + requested_module + " was not found.");
                    }
                    isolatedModule.dependencies = dependencies;
                    reload_method_name = isolatedModule.reload != null ? '_reload' : 'reload';
                    isolatedModule[reload_method_name] = reload;
                    ref7 = mainCtx.defined;
                    for (i = 0, len = ref7.length; i < len; i++) {
                      key = ref7[i];
                      delete mainCtx.defined[key];
                    }
                    if ((ref8 = isolationCtx.isolateCompleteHandlers) != null ? ref8.length : void 0) {
                      ref9 = isolationCtx.isolateCompleteHandlers;
                      for (j = 0, len1 = ref9.length; j < len1; j++) {
                        handler = ref9[j];
                        handler(isolatedModule);
                      }
                    }
                    return typeof done === "function" ? done(isolatedModule) : void 0;
                  };
                })(this));
              };
              return reload(function(isolatedModule) {
                return load(isolatedModule);
              });
            };
          })(this));
        } catch (_error) {
          err = _error;
          urlForException = "https://github.com/tnwinc/Isolate/wiki/Error:-An-error-occurred-while-preparing-to-isolate-the-module";
          err.message = "An error occurred while preparing to isolate the module: " + requested_module + "\nFor more information, see " + urlForException + "\nInner Exception:\n" + err.message;
          throw err;
        }
      };

      IsolationContext.prototype.useRequire = function(_require) {
        IsolationContext._require = _require;
        return this;
      };

      IsolationContext.prototype.passthru = function() {
        var i, len, path, paths;
        paths = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if ('[object Array]' === getType(paths[0])) {
          paths = paths[0];
        }
        for (i = 0, len = paths.length; i < len; i++) {
          path = paths[i];
          this.rules.unshift({
            matcher: getMatcherForPath(path, true),
            handler: passthru
          });
        }
        return this;
      };

      IsolationContext.prototype.map = function() {
        var args, handler, path, ref;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (getType(args[0]) === '[object Object]') {
          ref = args[0];
          for (path in ref) {
            if (!hasProp.call(ref, path)) continue;
            handler = ref[path];
            this.map(path, handler);
          }
        } else {
          path = args[0];
          handler = args[1];
          this.rules.unshift({
            matcher: getMatcherForPath(path),
            handler: handler instanceof IsolationFactory ? handler.factory : function() {
              return handler;
            }
          });
        }
        return this;
      };

      IsolationContext.prototype.mapType = function() {
        var args, handler, ref, type;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (getType(args[0]) === '[object Object]') {
          ref = args[0];
          for (type in ref) {
            if (!hasProp.call(ref, type)) continue;
            handler = ref[type];
            this.mapType(type, handler);
          }
        } else {
          type = "[object " + (args[0].toLowerCase()) + "]";
          handler = args[1];
          this.typeHandlers[type] = handler instanceof IsolationFactory ? handler.factory : function() {
            return handler;
          };
        }
        return this;
      };

      IsolationContext.prototype.willRequire = function() {
        var args, ref;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.ensuredAsyncModules || (this.ensuredAsyncModules = []);
        (ref = this.ensuredAsyncModules).push.apply(ref, args);
        return this;
      };

      IsolationContext.prototype.reset = function() {
        this.rules.length = 0;
        this.typeHandlers = {};
        return this;
      };

      IsolationContext.prototype.mapAsFactory = function() {
        var args, factory, path, ref;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (args.length === 1) {
          if ('[object Function]' === getType(args[0])) {
            return new IsolationFactory(args[0]);
          } else {
            ref = args[0];
            for (path in ref) {
              if (!hasProp.call(ref, path)) continue;
              factory = ref[path];
              this.mapAsFactory(path, factory);
            }
          }
        } else {
          path = args[0];
          factory = args[1];
          this.rules.unshift({
            matcher: getMatcherForPath(path),
            handler: factory
          });
        }
        return this;
      };

      IsolationContext.prototype.isolateComplete = function(handler) {
        (this.isolateCompleteHandlers = this.isolateCompleteHandlers || []).push(handler);
        return this;
      };

      IsolationContext.prototype.newContext = function(name) {
        var ctx, handler, ref, ref1, ref2, type;
        name = name || ("isolation_context_" + (Math.floor(Math.random() * 10000)));
        ctx = new IsolationContext(name);
        ctx.rules = (ref = this.rules) != null ? ref.slice(0) : void 0;
        ref1 = this.typeHandlers;
        for (type in ref1) {
          handler = ref1[type];
          ctx.typeHandlers[type] = handler;
        }
        ctx.isolateCompleteHandlers = (ref2 = this.isolateCompleteHandlers) != null ? ref2.slice(0) : void 0;
        return ctx;
      };

      return IsolationContext;

    })();
    IsolationContext.env = IsolationContext.prototype.env = typeof exports === 'object' ? 'commonjs' : 'amd';
    IsolationContext.contexts = {};
    return new IsolationContext;
  });

}).call(this);
